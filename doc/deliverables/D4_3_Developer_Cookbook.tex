\input{header}

\title{MyThOS D4.3 Developer Cookbook}
\author{Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta}

\hypersetup{
  pdftitle={MyThOS D4.3 Developer Cookbook},
  pdfsubject={MyThOS Deliverable},
  pdfauthor={Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta},
  pdfkeywords={MyThOS} % comma separated
}

\begin{document}
\selectlanguage{ngerman}
\maketitle

\begin{abstract} 

Dieses Deliverable richtet sich an externe Anwender und
dokumentiert die Tools als auch die Grundz\"uge des Programmiermodells anhand von
Beispielen (Kochrezepten).  

\end{abstract}

\newpage
\tableofcontents
% --- content ------------------------------------------------------------------

\selectlanguage{UKenglish}
\section{Compiling an Application}

The \mythos kernel loads an initial application after the operating system is booted and the available hardware is appropriately configured. This initial application is embedded into the kernel image and thus has to be compiled together with the kernel image. A dynamic application loader is intended to be included in future versions of \mythos.

Due to  the reduced nature of \mythos, applications have to be compiled carefully to be executable on \mythos. This will also be true once the dynamic application loader is in place. Currently \mythos does offer the full interface of commonly used libraries like LibC. Therefore, the compiler has to be instructed not to include exception handling into the code (\texttt{-fno-exceptions}) and omit including stack protectors (\texttt{-fno-stack-protector}). The linker has to be configured to not link against the standard libraries (\texttt{-nostdlib}) and link against all other libraries statically (\texttt{-static}), since dynamically loaded libraries are not yet supported by \mythos. However, GCC-specific functions are included in the code of \mythos. Therefore, these libraries have to be included into the code (\texttt{-lgcc}).

Since \mythos is designed to run on manycore architectures, which often have limited support for advanced istruction set extensions, these should be disabled in the compiler. When compiling an application for the Intel\textcopyright~Xeon~Phi\texttrademark{}, all of MMX, SSE, SSE2, SSE3 and 3DNow should be disabled (\texttt{-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow}).


\section{Interface of \mythos System Calls}
Compared to general purpose operating systems, \mythos offers a relatively
small set of system calls for the interaction of applications with the
operating system kernel. In the following all system calls are listed,
including a description of their semantics.

\begin{description}
\item[void syscall\_debug(char const* start, uint64\_t length):] This system
call is used to output debug messages to the text console. In the current
implementation, the output is redirected to a static memory buffer, from where
it is then output to the user's terminal by an helper application running on the
\mythos host. The parameter \texttt{start} points to the buffer containing the
text to be output, \texttt{length} determines the length of the string. After
the output is written into the buffer, the syscall returns to the application.
The actual output to the user's terminal is then executed asynchronously on the
host computer.
\item[void syscall\_exit(uint64\_t rescode):] This system call is called to exit
the currently running application. When issuing this system call, the currently
running \texttt{ExecutionContext} exits itself and yields control to the kernel.
The parameter \texttt{rescode} follows the usual semantics of a result code,
where the value $0$ indicates successful execution of the application or thread,
while all other result codes indicate unsuccessful execution, with a semantic,
that is up to the application.
\item[KEvent syscall\_invoke(CapPtr portal, CapPtr object, void* userctx):] All
functionality in the kernel of \mythos is encapsulated into kernel objects.
Using this system call, applications can interact with these kernel objects in a
well-defined and controlled manner. This system call can be used to request a
specific service, from the kernel object \texttt{object}. For the communication
a portal is used, that is passed to the system call in the parameter
\texttt{portal}. The called kernel object does not necessarily have to be
located locally. The translation of the application's system calls to either
local or remote system calls is transparent to the user. An additional reference
\texttt{userctx} is passed, which is later returned to the application upon
reply of the kernel object. This system call is executed asynchronously.
Additional system calls have to be issued to check for the result of the
invocation.
\item[KEvent syscall\_poll():] This system call checks, whether the application
received a response to a previously issued system call or an invocation by a
remote portal. If a notification was received, this is indicated in
\texttt{state}-member of the returned \texttt{KEvent}-object. The reference,
that was passed to the corresponding invoke system call (either locally or
remotely via a portal) is made available to the application in the
\texttt{user}-member of the returned object. This system call returns
immediately, even if there was no notification pending.
\item[KEvent syscall\_wait():] This system call follows the same semantics as
the \texttt{syscall\_poll} system call, but blocks until a notification was
received. It's therefore follows a synchronous processing model.
\item[KEvent syscall\_invoke\_poll(CapPtr portal, CapPtr object, void* userctx)]
\item[KEvent syscall\_invoke\_wait(CapPtr portal, CapPtr object, void*
userctx):] These two system calls combine an invocation of a kernel object with
the check for pending notifications. They follow the semantics of the individual
system calls as described above and are available in a blocking (wait) and a
non-blocking (poll) implementation. The combination of two system calls into a
single one resembles the common send-recevice pattern and potentially can reduce
the number of required system calls and therefore the number of switches from
user space to kernel space and back.
\end{description}

\section{Interface of the \mythos Runtime Environment} Due to the focus of the
\mythos project on developing an operating system, the support for applications
in terms of runtime environment are limited, compared to general purpose
operating systems like Linux. The main point of interaction with the operating
system is the use of portals, which represent the communication endpoint between
the application and \mythos. The interaction between the application and the
portals is detailed in the previous section of this document.

For the interaction of applications with other kernel objects, some user space
representations are provided to application developers, that encapsulate the
communication with the respective kernel object and therefore provide the
developer with a more specialised interface than generic portals. In the
following, these user space representations and their interfaces are presented.

\subsection{CapMap}
A capability map object is used to manage the application's capability space by creating, moving, deleting or revoking capability pointers, which are references to kernel objects that can be accessed and utilised by the application.

A new capability map object can be instantiated by calling: \\
\textbf{\texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr
factory, CapPtrDepth indexbits, CapPtrDepth guardbits, CapPtr guard)}}. 

This method creates a new capability map via the portal \texttt{pr} in the memory
area \texttt{kmem} using the factory referenced by \texttt{factory}.
Additionally, indexbits and guardbits can be set, which are further detailed in
Deliverable D2.2.

An existing capability map can be utilised to manipulate the capability entries, which it contains. New capabilities can be created using the methods \texttt{PortalFutureRef<void> derive(PortalRef pr, CapPtr src, CapPtrDepth srcDepth, CapPtr dstCs, CapPtr dst, CapPtrDepth dstDepth, CapRequest req)} and \texttt{reference}, which implements the same method signature.  The methods create new capabilities, that are children of or references to an existing capability \texttt{src} in the called capability space. The newly created capabilities are then inserted into the capability space \texttt{dstCs} at the location \texttt{dst}. Additionally, desired capability flags can be passed in the parameter \texttt{req}. 

The method \texttt{ PortalFutureRef<void> move(PortalRef pr, CapPtr src, \\CapPtrDepth srcDepth, CapPtr dstCs, CapPtr dst, CapPtrDepth dstDepth)} can be used to move a capability \texttt{src} from the called capability space to another capability space \texttt{dstCs} at location \texttt{dst}. Thereby, capabilities can be separated into multiple capability spaces to pass them to individual applications or application parts.

To delete a capability from the capability map the method \texttt{PortalFutureRef<void> deleteCap(PortalRef pr, CapPtr src, CapPtrDepth srcDepth)} can be called, which deletes the capability \texttt{src} from the map. Furthermore, the method \texttt{PortalFutureRef<void> deleteCap(PortalRef pr, KObject src)} can be used to delete a given kernel object from the map, regardless of its assigned corresponding capability. For these two methods, respective \texttt{revokeCap} methods exist with the same signatures, that can be used to revoke individual capabilities.

\subsection{DebugSink}
This class represents a small wrapper for the debug system call and can be used
to output debug information (or any other text) to the text console and thereby
make it available to users or developers. Its functionality is contained in the
function \texttt{void write(char const* str, size\_t len)}, which takes a string
and its length as input parameters and outputs this string to the console.

\subsection{ExecutionContext}
As detailed in the deliverable D2.2, Execution Context objects are used to
represent the execution state of a single software thread. Therefore, they are a
very important interaction point for application developers to control the
degree of parallelism in their applications and to achieve actual concurrency
within \mythos. Their interface looks as follows:

\texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem,
CapPtr factory, PageMap as, CapMap cs, CapPtr sched, void* stack, StartFun
start, void* userctx):}
This function is used to create a new \texttt{ExecutionContext} kernel object.
The parameter \texttt{pr} specifies the pointer to the portal that should be
used for this operation. \texttt{kmem} specifies the kernel memory area, in
which the new EC should be allocated. \texttt{factory} is a pointer to the
kernel object responsible for the actual creation of the object and has to be
provided by the operating system beforehand. In the parameters \texttt{as} and
\texttt{cs} the address space and the capability space of the application are
passed. The parameter \texttt{sched} specifies the scheduling context, which is
designated to execute the newly created EC, while its user space stack is placed
at the virtual address specified by the parameter \texttt{stack}. Finally,
\texttt{start} is a pointer to the initial function  executed by the EC in user
space and \texttt{userctx} can be used by the application developer to later
identify individual ECs and is passed to the function specified by
\texttt{start}.

  \texttt{PortalFutureRef<void> configure(PortalRef pr, PageMap as, CapMap cs,
  CapPtr sched):} This method is used to configure the EC, which is accessed via
  the local portal \texttt{pr} to use the page map, capability map and
  scheduling context, specified by \texttt{as}, \texttt{cs} or \texttt{sched}
  respectively, in the future.

\subsection{Frame}
A frame object represents a memory frame, that can be accessed by the
application and is allocated from an \texttt{UntypedMemory} object via the
method \texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem,
CapPtr factory, size\_t size, size\_t alignment)}. Additionally to the local
portal \texttt{pr}, the allocation pool \texttt{kmem} and the factory for
\texttt{Frame} objects \texttt{factory}, the size and the alignment requirements
for the newly allocated frame are passed as arguments in the parameters
\texttt{size} and \texttt{alignment}.

The \texttt{PortalFutureRef<protocol::Frame::Info> info(PortalRef pr)} method
returns various information about a given memory frame, like its size and
alignment accompanied by permissions, that are set to this memory frame, like
its executable and writable flags.

\subsection{PageMap}
Objects of the class \texttt{PageMap} represent a single table in the
hierarchical page table structure of the application. On creation, each page map
and their contents are bound to a specific level in the page table hierarchy.
The entries of a page map point to either a memory frame of the same level or a
page map of the next lower level.
\texttt{PageMap} objects can be created using the method
\texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr
factory, size\_t level)}. Besides the local portal \texttt{pr}, the memory area
used for allocation \texttt{kmem} and the page map factory \texttt{factory}, the
level of the page map has to be specified.

After creation (and potentially configuration) a page map can be put into action
by calling the method \texttt{PortalFutureRef<protocol::PageMap::Result>
installMap(PortalRef pr, PageMap pagemap, uintptr\_t vaddr, size\_t level,
MapFlags flags)}. Thereby, the page map is mapped into the higher level table
\texttt{pagemap}, which then contains mappings for the virtual addresses in the
range of \texttt{vaddr} at the given level of page tables. Additionally, flags
can be set on the page map, e.g. write permissions or caching behaviour. A page
map can be removed from the page table hierarchy using the method
\texttt{PortalFutureRef<protocol::PageMap::Result> removeMap(PortalRef pr, \\
uintptr\_t vaddr, size\_t level)}.

Using the method \texttt{PortalFutureRef<protocol::PageMap::Result> \\
mmap(PortalRef pr, Frame frame, uintptr\_t vaddr, size\_t size, MapFlags flags)},
a given memory frame can be mapped to the virtual user space address
\texttt{vaddr}. Again, flags can be specified to customise the mapping process.
The reverse operation is available via the method
\texttt{PortalFutureRef<protocol::PageMap::Result> munmap(PortalRef pr,
uintptr\_t vaddr, size\_t size)}, which removes the frame from the page map.
Existing mappings can be remapped from \texttt{sourceAddr} to \texttt{destAddr}
by calling the method \texttt{PortalFutureRef<protocol::PageMap::Result>
remap(PortalRef pr, uintptr\_t sourceAddr, uintptr\_t destAddr, size\_t size)}.
Flags, that were previously set for a page map or a frame can be altered to a
new set of flags by using the method
\texttt{PortalFutureRef<protocol::PageMap::Result> mprotect(PortalRef pr,
uintptr\_t vaddr, size\_t size, MapFlags flags)}.
The semantics of these method calls are comparable to the linux system calls
\texttt{mmap}, \texttt{munmap}, \texttt{mremap} and \texttt{mprotect}.


\subsection{Tasklet}
Tasklets are used for two purposes in \mythos. They represent the smallest unit
of executed code and at the same time serve as a token in a token-based flow
control system. A tasklet encapsulates a single functor, that can be set and
retrieved. For this purpose the \texttt{Tasklet} class exposes two
self-explanatory methods:

\lstset{language=c++}
\begin{lstlisting}
template<class FUNCTOR>
void set(FUNCTOR const&& fun);

template<class MSG>
MSG get() const;
\end{lstlisting}

\subsection{UntypedMemory}
This object represents a memory pool, from which memory can be allocated to be
either used by the application (Frames) or to be used to host kernel objects.
The \texttt{UntypedMemory} objects only expose one function to the user space,
which is defined as \texttt{PortalFutureRef<void> create(PortalRef pr,
UntypedMemory kmem, CapPtr factory, size\_t size, size\_t alignment)}. This
method is used to derive an \texttt{UntypedMemory} object from an
\texttt{UntypedMemory} object, spliiting one of these objects into two. Thereby,
a hierarchical memory structure is built up. For this purpose, it is passed a
pointer to the local portal \texttt{pr}, the original \texttt{UntypedMemory}
object \texttt{kmem}, a pointer to an object capable of creating new
\texttt{UntypedMemory} objects \texttt{factory} and the new objects desired size
and memory alignment.

\subsection{Library Functions} In addition to the functions detailed above, that
directly interact with the operating system via system calls, a small set of
convenience functions was is implemented, that conform to the default interfaces
known for these functions from the C/C++ string library. Currently, the set of
functions comprises of \texttt{memcpy} to copy memory ranges, \texttt{memset} to
initialise memory regions, \texttt{strlen} to determine the length of a string
and \texttt{strcmp} to check two strings for the lexical order and equality.

\section{Moving a function from user space to kernel space}

When developing an application, the developer at some point may decide to move
parts of its functionality to the kernel space to improve the application's
performance. In this section we describe, how to extend an existing kernel
object with an additional function, that then can be called from the user space
application. The process of initially developing a kernel object including all
required methods is laid out in deliverable D3.3.

For convenience, each kernel object that is invocable from user space should
feature a runtime representation, which serves as a wrapper.  For our Example
object the according runtime representation is listed in
Listing~\ref{lst:obj-runtime}. Runtime representations of kernel objects are
typically located in the folder \texttt{runtime/kobject/runtime} and
encapsulate the calls to the portal of the current Execution Context (e.g. see
Listing~\ref{lst:obj-runtime}, Line~13). Here, a runtime method has to be
defined, that calls the \texttt{tryInvoke} method on a portal and may pass
additional arguments to that method.

\lstset{language=c++,caption=Object's Runtime Representation,label=lst:obj-runtime}
\begin{lstlisting}
#include "runtime/PortalBase.hh"
#include "mythos/protocol/Example.hh"
#include "runtime/UntypedMemory.hh"

namespace mythos {

  class Example : public KObject
  {
  public:
    Example(CapPtr cap) : KObject(cap) {}

    PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory) {
      return pr.tryInvoke<protocol::Example::Create>(kmem.cap(), _cap, factory);
    }

    PortalFutureRef<void> printMessage(PortalRef pr, char const* str, size_t bytes) {
      return pr.tryInvoke<protocol::Example::PrintMessage>(_cap, str, bytes);
    }
  };

} // namespace mythos
\end{lstlisting}

For data exchange between user space and kernel space, invocation buffers are
used, that can be arbitrarily used by applications. Their contents are
described by protocols, that are stored in
\texttt{kernel/mythos/invocation/mythos/protocol}. The corresponding class in
this folder contains a list of available methods, that has to be extended with
the new one. As an example, consider the protocol definition for our example object in
\texttt{kernel/mythos/invocation/mythos/protocol/Example.hh}: 

\lstset{language=c++,caption=Object's Protocol Definition,label=lst:obj-protocol}
\begin{lstlisting}
#include "mythos/protocol/common.hh"
#include "mythos/protocol/UntypedMemory.hh"
#include <cstring>

namespace mythos {
namespace protocol {

struct Example {
	constexpr static uint8_t proto = EXAMPLE;

	enum Methods : uint8_t {
		PRINT_MESSAGE,
	};

	struct PrintMessage : public InvocationBase {
		typedef InvocationBase response_type;
		constexpr static uint16_t label = (proto<<8) + PRINT_MESSAGE;
		PrintMessage(char const* str, size_t bytes)
		: InvocationBase(label,getLength(this))
		{
			if (bytes>InvocationBase::maxBytes) bytes = InvocationBase::maxBytes;
			this->bytes = uint16_t(bytes);
			this->tag.length = uint8_t((bytes+3)/4);
			memcpy(message, str, bytes);
		}
		uint16_t bytes;
		char message[InvocationBase::maxBytes-2];
	};

	struct Create : public UntypedMemory::CreateBase {
		Create(CapPtr dst, CapPtr factory) : CreateBase(dst, factory) {}
	};

	template<class IMPL, class... ARGS>
	static Error dispatchRequest(IMPL* obj, uint8_t m, ARGS const&...args) {
		switch(Methods(m)) {
		case PRINT_MESSAGE: return obj->printMessage(args...);
		default: return Error::NOT_IMPLEMENTED;
		}
	}

};

} // namespace protocol
} // namespace mythos
\end{lstlisting}


Additionally, the format of the invocation buffer has to be specified here,
inside a method-specific struct which includes a constructor that receives all
arguments, that were previously passed to the runtime object.  Furthermore, the
method \texttt{dispatchMethod} has to be adapted to call the correct method of
the kernel object when receiving a message. This method of the kernel object
then carries out the actual work that the developer wanted to move into the
kernel.

The actual kernel object's implementation is stored in
\texttt{objects/<objectName>/\\objects}. Here, the method called by the
protocol's dispatcher has to be implemented. This method is responsible for
extracting the required information from the invocation buffer and processing
it. Data can be returned to the application through the invocation buffer.

% ------------------------------------------------------------------------------
% \bibliographystyle{alpha}
% \bibliography{literature}

\end{document}
