\input{header}

\title{MyThOS D4.3 Developer Cookbook}
\author{Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta}

\hypersetup{
  pdftitle={MyThOS D4.3 Developer Cookbook},
  pdfsubject={MyThOS Deliverable},
  pdfauthor={Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta},
  pdfkeywords={MyThOS} % comma separated
}

\begin{document}
\selectlanguage{ngerman}
\maketitle

\begin{abstract}
Dieses Deliverable richtet sich an externe Anwender und dokumentiert die Tools als auch die Grundzüge des Programmiermodells anhand von Beispielen („Kochrezepten“).
\end{abstract}

\newpage
\tableofcontents
% --- content ------------------------------------------------------------------

\selectlanguage{UKenglish}
\section{Compiling an Application}

The \mythos kernel loads an initial application after the operating system is booted and the available hardware is appropriately configured. This initial application is embedded into the kernel image and thus has to be compiled together with the kernel image. A dynamic application loader is intended to be included in future versions of \mythos.

Due to  the reduced nature of \mythos, applications have to be compiled carefully to be executable on \mythos. This will also be true once the dynamic application loader is in place. Currently \mythos does offer the full interface of commonly used libraries like LibC. Therefore, the compiler has to be instructed not to include exception handling into the code (\texttt{-fno-exceptions}) and omit including stack protectors (\texttt{-fno-stack-protector}). The linker has to be configured to not link against the standard libraries (\texttt{-nostdlib}) and link against all other libraries statically (\texttt{-static}), since dynamically loaded libraries are not yet supported by \mythos. However, GCC-specific functions are included in the code of \mythos. Therefore, these libraries have to be included into the code (\texttt{-lgcc}).

Since \mythos is designed to run on manycore architectures, which often have limited support for advanced istruction set extensions, these should be disabled in the compiler. When compiling an application for the Intel\textcopyright~Xeon~Phi\texttrademark{}, all of MMX, SSE, SSE2, SSE3 and 3DNow should be disabled (\texttt{-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow}).


\section{Interface of \mythos System Calls}
Compared to general purpose operating systems, \mythos offers a relatively
small set of system calls for the interaction of applications with the
operating system kernel. In the following all system calls are listed,
including a description of their semantics.

\begin{description}
\item[void syscall\_debug(char const* start, uint64\_t length):] This system
call is used to output debug messages to the text console. In the current
implementation, the output is redirected to a static memory buffer, from where
it is then output to the user's terminal by an helper application running on the
\mythos host. The parameter \texttt{start} points to the buffer contaitning the
text to be output, \texttt{length} determines the length of the string. After
the output is written into the buffer, the syscall returns to the application.
The actual output to the user's terminal is then executed asynchronously on the
host computer.
\item[void syscall\_exit(uint64\_t rescode):] This system call is called to exit
the currently running application. When issuing this system call, the currently
running \texttt{ExecutionContext} exits itself and yields control to the kernel.
The parameter \texttt{rescode} follows the usual semantics of a result code,
where the value $0$ indicates succesful execution of the application or thread,
while all other result codes indicate unsuccesful execution, with a semantic,
that is up to the application.
\item[KEvent syscall\_invoke(CapPtr portal, CapPtr object, void* userctx):] All
functionality in the kernel of \mythos is encapsulated into kernel objects.
Using this system call, applications can interact with these kernel objects in a
well-defined and controlled manner. This system call can be used to request a
specific service, from the kernel object \texttt{object}. For the communication
a portal is used, that is passed to the system call in the parameter
\texttt{portal}. The called kernel object does not necessarily have to be
located locally. The translation of the application's system calls to either
local or remote system calls is transparent to the user. An additional reference
\texttt{userctx} is passed, which is later returned to the application upon
reply of the kernel object. This system call is executed asynchronously.
Additional system calls have to be issued to check for the result of the
invocation.
\item[KEvent syscall\_poll():] This system call checks, whether the application
received a response to a previously issued system call or an invocation by a
remote portal. If a notification was received, this is indicated in
\texttt{state}-member of the returned \texttt{KEvent}-object. The reference,
that was passed to the corresponsding invoke system call (either locally or
remotely via a portal) is made available to the application in the
\texttt{user}-member of the returned object. This system call returnes
immediately, even if there was no notification pending.
\item[KEvent syscall\_wait():] This system call follows the same semantics as
the \texttt{syscall\_poll} system call, but blocks until a notification was
received. It's therefore follows a synchronous processing model.
\item[KEvent syscall\_invoke\_poll(CapPtr portal, CapPtr object, void* userctx)]
\item[KEvent syscall\_invoke\_wait(CapPtr portal, CapPtr object, void*
userctx):] These two system calls combine an invocation of a kernel object with
the check for pending notifications. They follow the semantics of the individual
system calls as described above and are available in a blocking (wait) and a
non-blocking (poll) implementation. The combination of two system calls into a
single one resembles the common send-recevice pattern and potentially can reduce
the number of required system calls and therefore the number of switches from
user space to kernel space and back.
\end{description}

\section{Interface of the \mythos Runtime Environment} Due to the focus of the
\mythos project on developing an operating system, the support for applications
in terms of runtime environment are limited, compared to general purpose
operating systems like Linux. The main point of interaction with the operating
system is the use of portals, which represent the communication endpoint between
the application and \mythos. The interaction between the applciation and the
portals is detailed in the previous section of this document.

For the ineraction of applications with other kernel objects, some user space
representations are provided to application developers, that encapsulate the
communication with the respective kernel object and therefore provide the
developer with a more specialized interface than generic portals. In the
following, these user space representations and their interfaces are presented.

\subsection{CapMap}


\subsection{DebugSink}
This class represents a small wrapper for the debug system call and can be used
to ouput debug information (or any other text) to the text console and thereby
make it available to users or developers. Its functionality is contained in the
function \texttt{void write(char const* str, size\_t len)}, which takes a string
and its length as input parameters and outputs this string to the console.

\subsection{ExecutionContext}
As detailed in the deliverable D2.2, Execution Context objects are used to
represent the execution state of a single software thread. Therefore, they are a
very important interaction point for application developers to control the
degree of parallelism in their applications and to achieve actual concurrency
witin \mythos. Their interface looks as follows:

\texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem,
CapPtr factory, PageMap as, CapMap cs, CapPtr sched, void* stack, StartFun
start, void* userctx):}
This function is used to create a new \texttt{ExecutionContext} kernel object.
The parameter \texttt{pr} specifies the pointer to the portal that should be
used for this operation. \texttt{kmem} specifies the kernel memory area, in
which the new EC should be allocated. \texttt{factory} is a pointer to the
kernel object responsible for the actual creation of the object and has to be
provided by the operating system beforehand. In the parameters \texttt{as} and
\texttt{cs} the address space and the capability space of the application are
passed. The parameter \texttt{sched} specifies the scheduling context, which is
designated to execute the newly created EC, while its user space stack is placed
at the virtual address specified by the parameter \texttt{stack}. Finally,
\texttt{start} is a pointer to the initial function  executed by the EC in user
space and \texttt{userctx} can be used by the application developer to later
identify individual ECs and is passed to the function specified by
\texttt{start}.

  \texttt{PortalFutureRef<void> configure(PortalRef pr, PageMap as, CapMap cs,
  CapPtr sched):} This method is used to configure the EC, which is accessed via
  the local portal \texttt{pr} to use the page map, capability map and
  scheduling context, specified by \texttt{as}, \texttt{cs} or \texttt{sched}
  respectively, in the future.

\subsection{Frame}
A frame object represents a memory frame, that can be accessed by the
application and is allocated from an \texttt{UntypedMemory} object via the
method \texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem,
CapPtr factory, size\_t size, size\_t alignment)}. Additionally to the local
portal \texttt{pr}, the allocation pool \texttt{kmem} and the factory for
\texttt{Frame} objects \texttt{factory}, the size and the alignment requirements
for the newly allocated frame are passed as arguments in the parameters
\texttt{size} and \texttt{alignment}.

The \texttt{PortalFutureRef<protocol::Frame::Info> info(PortalRef pr)} method
returns various information about a given memory frame, like its size and
alignment accompanied by permissions, that are set to this memory frame, like
its exacutable and writable flags.

\subsection{PageMap}
Objects of the class \texttt{PageMap} represent a single table in the
hierarchical page table structure of the application. On creation, each page map
and their contents are bound to a specific level in the page table hierarchy.
The entries of a page map point to either a memory frame of the same level or a
page map of the next lower level.
\texttt{PageMap} objects can be created using the method
\texttt{PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr
factory, size\_t level)}. Besides the local portal \texttt{pr}, the memory area
used for allocation \texttt{kmem} and the page map factory \texttt{factory}, the
level of the page map has to be specified.

After creation (and potentially configuration) a page map can be put into action
by calling the method \texttt{PortalFutureRef<protocol::PageMap::Result>
installMap(PortalRef pr, PageMap pagemap, uintptr\_t vaddr, size\_t level,
MapFlags flags)}. Thereby, the page map is mapped into the higher level table
\texttt{pagemap}, which then contains mappings for the virtual addresses in the
range of \texttt{vaddr} at the given level of page tables. Additionally, flags
can be set on the page map, e.g. write permissions or caching behaviour. A page
map can be removed from the page table hierarchy using the method
\texttt{PortalFutureRef<protocol::PageMap::Result> removeMap(PortalRef pr,
uintptr\_t vaddr, size\_t level)}.

Using the method \texttt{PortalFutureRef<protocol::PageMap::Result>
mmap(PortalRef pr, Frame frame, uintptr\_t vaddr, size\_t size, MapFlags flags)},
a given memory frame can be mapped to the virtual user space address
\texttt{vaddr}. Again, flags can be specified to customize the mapping process.
The reverse operation is available via the method
\texttt{PortalFutureRef<protocol::PageMap::Result> munmap(PortalRef pr,
uintptr\_t vaddr, size\_t size)}, which removes the frame from the page map.
Existing mappings can be remapped from \texttt{sourceAddr} to \texttt{destAddr}
by calling the method \texttt{PortalFutureRef<protocol::PageMap::Result>
remap(PortalRef pr, uintptr\_t sourceAddr, uintptr\_t destAddr, size\_t size)}.
Flags, that were previously set for a page map or a frame can be altered to a
new set of flags by using the method
\texttt{PortalFutureRef<protocol::PageMap::Result> mprotect(PortalRef pr,
uintptr\_t vaddr, size\_t size, MapFlags flags)}.
The semantics of these method calls are comparable to the linux system calls
\texttt{mmap}, \texttt{munmap}, \texttt{mremap} and \texttt{mprotect}.


\subsection{Tasklet}
Tasklets are used for two purposes in \mythos. They represent the smallest unit
of executed code and at the same time serve as a token in a token-based flow
control system. A tasklet encapsulates a single functor, that can be set and
retrieved. For this purpose the \texttt{Tasklet} class exposes two
self-explainatory methods:

\begin{lstlisting}
template<class FUNCTOR>
void set(FUNCTOR const&& fun);

template<class MSG>
MSG get() const;
\end{lstlisting}

\subsection{UntypedMemory}
This object represents a memory pool, from which memory can be allocated to be
either used by the application (Frames) or to be used to host kernel objects.
The \texttt{UntypedMemory} objects only expose one function to the user space,
which is defined as \texttt{PortalFutureRef<void> create(PortalRef pr,
UntypedMemory kmem, CapPtr factory,size\_t size, size\_t alignment)}. This
method is used to derive an \texttt{UntypedMemory} object from an
\texttt{UntypedMemory} object, spliiting one of these objects into two. Thereby,
a hierarchical memory structure is built up. For this purpose, it is passed a
pointer to the local portal \texttt{pr}, the original \texttt{UntypedMemory}
object \texttt{kmem}, a pointer to an object capable of creating new
\texttt{UntypedMemory} objects \texttt{factory} and the new objects desired size
and memory alignment.

\subsection{Library Functions} In addition to the functions detailed above, that
directly interact with the operating system via system calls, a small set of
convenience functions was is implemented, that conform to the defualt interfaces
known for these functions from the C/C++ string library. Currently, the set of
functions comprises of \texttt{memcpy} to copy memory ranges, \texttt{memset} to
initialize memory regions, \texttt{strlen} to determine the length of a string
and \texttt{strcmp} to check two strings for the lexical order and equality.

% ------------------------------------------------------------------------------
% \bibliographystyle{alpha}
% \bibliography{literature}

\end{document}
