\input{header}

\title{MyThOS D4.3 Developer Cookbook}
\author{Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta}

\hypersetup{
  pdftitle={MyThOS D4.3 Developer Cookbook},
  pdfsubject={MyThOS Deliverable},
  pdfauthor={Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta},
  pdfkeywords={MyThOS} % comma separated
}

\begin{document}
\selectlanguage{ngerman}
\maketitle

\begin{abstract}

Dieses Deliverable richtet sich an externe Anwender und dokumentiert die Tools
als auch die Grundzuege des Programmiermodells anhand von Beispielen
(Kochrezepten).

\end{abstract}

\newpage
\tableofcontents
% --- content ------------------------------------------------------------------

\selectlanguage{UKenglish}

\section{Introduction}


\section{Creating and Compiling a User Application}
\label{sec:init-app}

The \mythos kernel automatically loads a default initial application after the
operating system is booted and the available hardware is appropriately
configured. The code of the init application lies in the
\texttt{kernel/app/init-app/app} directory of the kernel source tree and the
\texttt{int main()} function in \texttt{init.cc} is the entry point for the
application execution. In the following just some code excerpts are depicted
explaining the general application behavior. For better understanding please
introspect in parallel the original source code in \texttt{init.cc}.

The init application first creates a predefined kernel object (KO) of type
\texttt{mythos::Example}\footnote{implemented in
kernel/runtime/kobject/runtime/Example.hh} using a preconfigured untyped memory
space (\texttt{kmem}), portal (\texttt{portal}) and object factory
(\texttt{mythos::init::EXAMPLE\_FACTORY}):
\lstset{language=c++}

\begin{lstlisting}
mythos::Portal portal(mythos::init::PORTAL, msg_ptr);
mythos::UntypedMemory kmem(mythos::init::UM);
mythos::CapMap myCS(mythos::init::CSPACE); // Capability Space
...

int main() {
  ...
  mythos::Example example(mythos::init::APP_CAP_START);
  auto res1 = example.create(portal, kmem, mythos::init::EXAMPLE_FACTORY);
  res1.wait();
  ASSERT(res1.state() == mythos::Error::SUCCESS);
  ...
}
\end{lstlisting}

\noindent Each kernel object inherits from a generic type
\texttt{KObject}\footnote{see
\texttt{kernel/runtime/async/runtime/PortalBase.hh}}.
It encapsulates (and thus is referenced by) a certain kernel capability (e.g.
\texttt{mythos::init::APP\_CAP\_START}) which is later used for object
registration and query within application's capability space. While
\texttt{example} is only a user-space wrapper of the KO, the actual object
creation within the kernel is triggered by its \texttt{create(\ldots)} function.
The \texttt{create(\ldots)} function is object-specific and has to be provided
by the object developer. It triggers the required creation steps, which are
performed on behalf of a special predefined object protocol within the kernel.
That protocol guides the creation procedure and genral usage of the object (see
later Section~\ref{sec:objects} for more information). The procedure
automatically enacts the referenced object factory and registers the newly
created object within application's capability space.
Thereby, the \texttt{portal} object is required for communication with the
kernel and it performs the actual system call and protocol invocation. Since
system invocations are asynchronous, waiting for the result of each kernel
invocation via \texttt{res1.wait()} blocks until completion.

As next, the init application invokes a basic \texttt{printMessage(\ldots)}
function of the \texttt{Example} object (on line~1) and finally deletes that
object from its capability space (on line~4):

\lstset{language=c++}
\begin{lstlisting}
auto res2 = example.printMessage(res1.reuse(), obj, sizeof(obj)-1);
res2.wait();
ASSERT(res2.state() == mythos::Error::SUCCESS);
auto res3 = myCS.deleteCap(res2.reuse(), example);
res3.wait();
ASSERT(res3.state() == mythos::Error::SUCCESS);
\end{lstlisting}

\noindent For each new invocation the same protal is reused. The result of each
invocation is a reference to the engaged portal and its invocation buffer.
Beyond retrieving system call results, this mechanism also allows for checking
the execution status of a respective invocation, for example for polling or
waiting for a result (see \texttt{kernel/runtime/async/runtime/PortalBase.hh}).
MyThOS also supports a variety of error codes which are defined in
\texttt{kernel/mythos/error/mythos/Error.hh}, like for example \texttt{SUCCESS},
\texttt{INVALID\_ARGUMENT}, \texttt{NOT\_IMPLEMENTED},
\texttt{INVALID\_CAPABILITY}, \texttt{REQUEST\_DENIED} etc.

For more information on the peculiarities
and the procedure of object creation and invocation from a user application
please refer to Section~\ref{sec:objects}.

Finally the init app creates and activates two execution contexts \texttt{ec1}
and \texttt{ec2} which (when later executed) simply print a short debug message
(line~6) and then suspend (line~7). The following code excerpt shows the
creation and activation procedure of one \texttt{ExecutionContext}:

\lstset{language=c++}
\begin{lstlisting}
mythos::PageMap myAS(mythos::init::PML4);  // Address Space

void* thread_main(void* ctx)
{
  char const str[] = "hello thread!";
  mythos::syscall_debug(str, sizeof(str)-1);
  return 0;
}

int main() {
...
mythos::ExecutionContext ec1(mythos::init::APP_CAP_START);
auto res1 = ec1.create(portal, kmem, mythos::init::EXECUTION_CONTEXT_FACTORY,
                       myAS, myCS, mythos::init::SCHEDULERS_START,
                       thread1stack_top, &thread_main, nullptr);
res1.wait();
ASSERT(res1.state() == mythos::Error::SUCCESS);
...
}
\end{lstlisting}

An execution context is also a predefined MyThOS kernel object.
First a user space wrapper \texttt{ec1} is instantiated (line~12) and linked
with a certain capability\footnote{In this example the capability previously
used for the \texttt{Example} object is reused.}.
The actual creation and activation of the thread is triggered again by its
\texttt{create(\ldots)} function, which accepts a variety of parameters, as for
example the thread's address and capability space, stack, a thread factory and
scheduler references, as well as a reference to thread's entry point
\texttt{thread\_main(\ldots)} (line~3).

The init application is exported as a module (see
\texttt{kernel/app/init-app/mcconf.module}), which can be selectively included
in kernel's build process via the \texttt{mcconf} tool. The module definition is
the place, where also the build configuration and procedure of the application
can be customized in terms of build commands, compiler/linker flags and further
options. These are automatically included to the respective build targets for
the application in the final \texttt{Makefile} of the kernel. However, the
application is linked to a separate ELF-binary, which is automatically embedded
into the kernel image. A basic application loader in the kernel automatically
queries, loads and executes the application during runtime.
A dynamic application loader is intended to be included in future versions of
\mythos. The latter will allow for on-demand application loading and start from
a Xeon Phi host system.

The init application provides a good starting point and a general guideline for
the development of new MyThOS applications. An implementation should follow that
example and it must be integrated in a similar way into the directory structure
of the kernel (e.g. \texttt{kernel/app/\{my-app\}/app/init.cc}). It can be
exported and composed within the kernel as a different module (e.g.
\texttt{kernel/app/\{my-app\}/mcconf.module}). The provided module can be then
simply added to a general kernel configuration like for example
\texttt{kernel-amd64.config}. However, an application should at least implement
an \texttt{int main()} function. The kick-off procedure of the init application
is defined within the assembly file \texttt{kernel/app/{my-app}/app/start.S},
which should be reused by custom applications.

\noindent\textbf{Limitations:}

Due to  the reduced nature of \mythos, applications have to be compiled
carefully to be executable on \mythos. This will also be true once the dynamic
application loader is in place. Currently \mythos does offer the full interface
of commonly used libraries like LibC. Therefore, the compiler has to be
instructed not to include exception handling into the code
(\texttt{-fno-exceptions}) and omit including stack protectors
(\texttt{-fno-stack-protector}). The linker has to be configured to not link
against the standard libraries (\texttt{-nostdlib}) and link against all other
libraries statically (\texttt{-static}), since dynamically loaded libraries are
not yet supported by \mythos. However, GCC-specific functions are included in
the code of \mythos. Therefore, these libraries have to be included into the
code (\texttt{-lgcc}).

Since \mythos is designed to run on manycore architectures, which often have
limited support for advanced istruction set extensions, these should be disabled
in the compiler. When compiling an application for the
Intel\textcopyright~Xeon~Phi\texttrademark{}, all of MMX, SSE, SSE2, SSE3 and
3DNow should be disabled (\texttt{-mno-mmx -mno-sse -mno-sse2 -mno-sse3
-mno-3dnow}).

\section{Basic System Call Interface of \mythos}

Compared to general purpose operating systems, \mythos offers a relatively
small set of system calls for the interaction of applications with the
operating system kernel. In the following all system calls are listed,
including a description of their semantics. The user space wrappers of those
system calls are defined in \texttt{kernel/mythos/invocation/mythos/syscall.hh}.

\noindent \emph{Note:} This is the lowest level interface to the system. More
general abstractions based on that definitions exist. For example consider
object and system related invocations through a portal defined in
\texttt{kernel/runtime/async/runtime/PortalBase.hh}. These functions finally
decompose into basic system calls as defined in
\texttt{\\kernel/mythos/invocation/mythos/syscall.hh}.

\begin{description}
\item[void syscall\_debug(char const* start, uint64\_t length):] This system
call is used to print debug messages to the text console. In the current
implementation, the output is redirected to a static memory buffer, from where
it is then output to the user's terminal by an helper application running on the
\mythos host. The parameter \texttt{start} points to the buffer containing the
text to be output, \texttt{length} determines the length of the string. After
the output is written into the buffer, the syscall returns to the application.
The actual output to the user's terminal is then executed asynchronously on the
host computer.
\item[void syscall\_exit(uint64\_t rescode):] This system call is called to exit
the currently running application. When issuing this system call, the currently
running \texttt{ExecutionContext} exits itself and yields control to the kernel.
The parameter \texttt{rescode} follows the usual semantics of a result code,
where the value $0$ indicates successful execution of the application or thread,
while all other result codes indicate unsuccessful execution, with a semantic,
that is up to the application.
\item[KEvent syscall\_invoke(CapPtr portal, CapPtr object, void* userctx):] All
functionality in the kernel of \mythos is encapsulated into kernel objects.
Using this system call, applications can interact with these kernel objects in a
well-defined and controlled manner. This system call can be used to request a
specific service, from the kernel object \texttt{object}. For the communication
a portal is used, that is passed to the system call in the parameter
\texttt{portal}. The called kernel object does not necessarily have to be
located locally. The translation of the application's system calls to either
local or remote system calls is transparent to the user. An additional reference
\texttt{userctx} is passed, which is later returned to the application upon
reply of the kernel object. This system call is executed asynchronously.
Additional system calls have to be issued to check for the result of the
invocation. \emph{Note:} as already mentioned, for particular cases there are
already wrappers providing a higher level interface for handling results and
invocation status, as for example \texttt{PortalBase.h}.
\item[KEvent syscall\_poll():] This system call checks, whether the application
received a response to a previously issued system call or an invocation by a
remote portal. If a notification was received, this is indicated in
\texttt{state}-member of the returned \texttt{KEvent}-object. The reference,
that was passed to the corresponding invoke system call (either locally or
remotely via a portal) is made available to the application in the
\texttt{user}-member of the returned object. This system call returns
immediately, even if there was no notification pending.
\item[KEvent syscall\_wait():] This system call follows the same semantics as
the \texttt{syscall\_poll} system call, but blocks until a notification was
received. It's therefore follows a synchronous processing model.
\item[KEvent syscall\_invoke\_poll(CapPtr portal, CapPtr object, void* userctx)]
\item[KEvent syscall\_invoke\_wait(CapPtr portal, CapPtr object, void*
userctx):] These two system calls combine an invocation of a kernel object with
the check for pending notifications. They follow the semantics of the individual
system calls as described above and are available in a blocking (wait) and a
non-blocking (poll) implementation. The combination of two system calls into a
single one resembles the common send-receive pattern and potentially can reduce
the number of required system calls and therefore the number of switches from
user space to kernel space and back.
\end{description}

\noindent \emph{Note:} for portal based communication with the kernel, future
objects of type \texttt{kernel/runtime/async/runtime/FutureBase.hh} are used in
order to poll and synchronize on results. These are abstractions of the basic
\texttt{syscall\_\{poll,wait\}()} functions and the \texttt{PortalBase} type
inherits the implementation provided in \texttt{FutureBase.hh}.

\section{Interface of the \mythos Runtime Environment} Due to the focus of the
\mythos project on developing an operating system, the support for applications
in terms of runtime environment are limited, compared to general purpose
operating systems like Linux. The main point of interaction with the operating
system is the use of portals, which represent the communication endpoint between
the application and \mythos. The interaction between the application and the
portals is detailed in the previous section of this document.

For the interaction of applications with other kernel objects, some user space
representations are provided to application developers, that encapsulate the
communication with the respective kernel object and therefore provide the
developer with a more specialised interface than generic portals. In the
following, these user space representations and their interfaces are presented.

\subsection{CapMap}

A capability map object is used to manage the application's capability space by
creating, moving, deleting or revoking capability pointers. These are references
to kernel objects that can be accessed and utilised by the application.

A new capability map object can be instantiated by calling:
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory, CapPtrDepth indexbits, CapPtrDepth guardbits, CapPtr guard)
\end{lstlisting}

\noindent This method creates a new capability map via the portal \texttt{pr} in the
memory area \texttt{kmem} using the factory referenced by \texttt{factory}.
Additionally, indexbits and guardbits can be set, which are further detailed in
Deliverable D2.2.

An existing capability map can be utilised to manipulate the capability entries,
which it contains. New capabilities can be created using the methods
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> derive(PortalRef pr, CapPtr src, CapPtrDepth srcDepth, CapPtr dstCs, CapPtr dst, CapPtrDepth dstDepth, CapRequest req)
\end{lstlisting}

\noindent and \texttt{reference(\ldots)}, which implements the same method
signature.  These methods create new capabilities, that are children of or
references to an existing capability \texttt{src} in the called capability
space. The newly created capabilities are then inserted into the capability
space \texttt{dstCs} at the location \texttt{dst}. Additionally, desired
capability flags can be specified in the parameter \texttt{req}.

The method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> move(PortalRef pr, CapPtr src, CapPtrDepth srcDepth, CapPtr dstCs, CapPtr dst, CapPtrDepth dstDepth)
\end{lstlisting}
\noindent can be
used to move a capability \texttt{src} from the called capability space to
another capability space \texttt{dstCs} at location \texttt{dst}. Thereby,
capabilities can be separated into multiple capability spaces to pass them to
individual applications or application parts.

To delete a capability from the capability map the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> deleteCap(PortalRef pr, CapPtr src, CapPtrDepth srcDepth)
\end{lstlisting}
\noindent can be called, which deletes the capability \texttt{src} from the
map. Furthermore, the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> deleteCap(PortalRef pr, KObject src)
\end{lstlisting}
\noindent can be used to delete a given kernel object from the map,
regardless of its assigned corresponding capability. For these two methods,
respective \texttt{revokeCap(\ldots)} methods exist with the same signatures, that can
be used to revoke individual capabilities.

\subsection{DebugSink}
This class represents a small wrapper for the debug system call and can be used
to output debug information (or any other text) to the text console and thereby
make it available to users or developers. Its functionality is contained in the
function
\lstset{language=c++,numbers=none}
\begin{lstlisting}
void write(char const* str, size_t len)
\end{lstlisting}
\noindent which takes a string
and its length as input parameters and outputs this string to the console.

\subsection{ExecutionContext}
As detailed in deliverable D2.2, Execution Context objects are used to
represent the execution state of a single software thread. Therefore, they are a
very important interaction point for application developers to control the
degree of parallelism in their applications and to achieve actual concurrency
within \mythos. Their interface looks as follows:

\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory, PageMap as, CapMap cs, CapPtr sched, void* stack, StartFun start, void* userctx)
\end{lstlisting}
This function is used to create a new \texttt{ExecutionContext} kernel object.
The parameter \texttt{pr} specifies the pointer to the portal that should be
used for this operation. \texttt{kmem} specifies the kernel memory area, in
which the new EC should be allocated. \texttt{factory} is a pointer to the
kernel object responsible for the actual creation of the object and has to be
provided by the operating system beforehand. In the parameters \texttt{as} and
\texttt{cs} the address space and the capability space of the application are
passed. The parameter \texttt{sched} specifies the scheduling context, which is
designated to execute the newly created EC, while its user space stack is placed
at the virtual address specified by the parameter \texttt{stack}.
\texttt{start} is a pointer to the initial function executed by the EC in user
space and \texttt{userctx} can be used by the application developer to later
identify individual ECs and is passed to the function specified by
\texttt{start}.

\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> configure(PortalRef pr, PageMap as, CapMap cs, CapPtr sched)
\end{lstlisting}
This method is used to configure the EC, which is accessed via
the local portal \texttt{pr} to use the page map, capability map and
scheduling context, specified by \texttt{as}, \texttt{cs} or \texttt{sched}
respectively, in the future.

\subsection{Frame}
A frame object represents a memory frame, that can be accessed by the
application and is allocated from an \texttt{UntypedMemory} object via the
method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory, size_t size, size_t alignment)
\end{lstlisting}
\noindent Additionally to the local
portal \texttt{pr}, the allocation pool \texttt{kmem} and the factory for
\texttt{Frame} objects \texttt{factory}, the size and the alignment requirements
for the newly allocated frame are passed as arguments in the parameters
\texttt{size} and \texttt{alignment}.

The method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::Frame::Info> info(PortalRef pr)
\end{lstlisting}
\noindent returns various information about a given memory frame, like its size and
alignment accompanied by permissions, that are set to this memory frame, like
its executable and writable flags.

\subsection{PageMap}
Objects of the class \texttt{PageMap} represent a single table in the
hierarchical page table structure of the application. On creation, each page map
and their contents are bound to a specific level in the page table hierarchy.
The entries of a page map point to either a memory frame of the same level or a
page map of the next lower level.
\texttt{PageMap} objects can be created using the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory, size_t level)
\end{lstlisting}
\noindent Besides the local portal \texttt{pr}, the memory area
used for allocation \texttt{kmem} and the page map factory \texttt{factory}, the
level of the page map has to be specified.

After creation (and potentially configuration) a page map can be put into action
by calling the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> installMap(PortalRef pr, PageMap pagemap, uintptr_t vaddr, size_t level, MapFlags flags)
\end{lstlisting}
\noindent Thereby, the page map is mapped into the higher level table
\texttt{pagemap}, which then contains mappings for the virtual addresses in the
range of \texttt{vaddr} at the given level of page tables. Additionally, flags
can be set on the page map, e.g. write permissions or caching behaviour. A page
map can be removed from the page table hierarchy using the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> removeMap(PortalRef pr, uintptr_t vaddr, size_t level)
\end{lstlisting}

With the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> mmap(PortalRef pr, Frame frame, uintptr_t vaddr, size_t size, MapFlags flags)
\end{lstlisting}
\noindent a given memory frame can be mapped to the virtual user space address
\texttt{vaddr}. Again, flags can be specified to customise the mapping process.
The reverse operation is available via the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> munmap(PortalRef pr, uintptr_t vaddr, size_t size)
\end{lstlisting}
\noindent which removes the frame from the page map.
Existing mappings can be remapped from \texttt{sourceAddr} to \texttt{destAddr}
by calling the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> remap(PortalRef pr, uintptr_t sourceAddr, uintptr_t destAddr, size_t size)
\end{lstlisting}
Flags, that were previously set for a page map or a frame can be altered to a
new set of flags by using the method
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<protocol::PageMap::Result> mprotect(PortalRef pr, uintptr_t vaddr, size_t size, MapFlags flags)}
\end{lstlisting}
The semantics of these method calls are comparable to the linux system calls
\texttt{mmap}, \texttt{munmap}, \texttt{mremap} and \texttt{mprotect}.


\subsection{Tasklet}
Tasklets are used for two purposes in \mythos. They represent the smallest unit
of executed code and at the same time serve as a token in a token-based flow
control system. A tasklet encapsulates a single functor, that can be set and
retrieved. For this purpose the \texttt{Tasklet} class exposes two
self-explanatory methods:

\lstset{language=c++}
\begin{lstlisting}
template<class FUNCTOR>
void set(FUNCTOR const&& fun);

template<class MSG>
MSG get() const;
\end{lstlisting}

\subsection{UntypedMemory}
This object represents a memory pool, from which memory can be allocated to be
either used by the application (Frames) or to be used to host kernel objects.
The \texttt{UntypedMemory} objects only expose one function to the user space,
which is defined as
\lstset{language=c++,numbers=none}
\begin{lstlisting}
PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory, size_t size, size_t alignment)
\end{lstlisting}
\noindent This method is used to derive an \texttt{UntypedMemory} object from an
\texttt{UntypedMemory} object, splitting one of these objects into two. Thereby,
a hierarchical memory structure is built up. For this purpose, it is passed a
pointer to the local portal \texttt{pr}, the original \texttt{UntypedMemory}
object \texttt{kmem}, a pointer to an object capable of creating new
\texttt{UntypedMemory} objects \texttt{factory} and the new objects desired size
and memory alignment.

\subsection{Library Functions} In addition to the functions detailed above, that
directly interact with the operating system via system calls, a small set of
convenience functions was is implemented, that conform to the default interfaces
known for these functions from the C/C++ string library. Currently, the set of
functions comprises of \texttt{memcpy} to copy memory ranges, \texttt{memset} to
initialise memory regions, \texttt{strlen} to determine the length of a string
and \texttt{strcmp} to check two strings for the lexical order and equality.

\section{Moving a function from user space to kernel space}
\label{sec:objects}

When developing an application, the developer at some point may decide to move
parts of its functionality to the kernel space to improve the application's
performance. In this section we describe, how to extend an existing kernel
object with an additional function, that then can be called from the user space
application. The process of initially developing a kernel object including all
required methods is laid out in deliverable D3.3.

For convenience, each kernel object that is invocable from user space should
feature a runtime representation, which serves as a wrapper.  For our Example
object the according runtime representation is listed in
Listing~\ref{lst:obj-runtime}. Runtime representations of kernel objects are
typically located in the folder \texttt{runtime/kobject/runtime} and
encapsulate the calls to the portal of the current Execution Context (e.g. see
Listing~\ref{lst:obj-runtime}, Line~13). Here, a runtime method has to be
defined, that calls the \texttt{tryInvoke} method on a portal and may pass
additional arguments to that method.

\lstset{language=c++,caption=Object's Runtime Representation,label=lst:obj-runtime}
\begin{lstlisting}
#include "runtime/PortalBase.hh"
#include "mythos/protocol/Example.hh"
#include "runtime/UntypedMemory.hh"

namespace mythos {

  class Example : public KObject
  {
  public:
    Example(CapPtr cap) : KObject(cap) {}

    PortalFutureRef<void> create(PortalRef pr, UntypedMemory kmem, CapPtr factory) {
      return pr.tryInvoke<protocol::Example::Create>(kmem.cap(), _cap, factory);
    }

    PortalFutureRef<void> printMessage(PortalRef pr, char const* str, size_t bytes) {
      return pr.tryInvoke<protocol::Example::PrintMessage>(_cap, str, bytes);
    }
  };

} // namespace mythos
\end{lstlisting}

For data exchange between user space and kernel space, invocation buffers are
used, that can be arbitrarily used by applications. Their contents are
described by protocols, that are stored in
\texttt{kernel/mythos/invocation/mythos/protocol}. The corresponding class in
this folder contains a list of available methods, that has to be extended with
the new one. As an example, consider the protocol definition for our example object in
\texttt{kernel/mythos/invocation/mythos/protocol/Example.hh}:

\lstset{language=c++,caption=Object's Protocol Definition,label=lst:obj-protocol}
\begin{lstlisting}
#include "mythos/protocol/common.hh"
#include "mythos/protocol/UntypedMemory.hh"
#include <cstring>

namespace mythos {
namespace protocol {

struct Example {
	constexpr static uint8_t proto = EXAMPLE;

	enum Methods : uint8_t {
		PRINT_MESSAGE,
	};

	struct PrintMessage : public InvocationBase {
		typedef InvocationBase response_type;
		constexpr static uint16_t label = (proto<<8) + PRINT_MESSAGE;
		PrintMessage(char const* str, size_t bytes)
		: InvocationBase(label,getLength(this))
		{
			if (bytes>InvocationBase::maxBytes) bytes = InvocationBase::maxBytes;
			this->bytes = uint16_t(bytes);
			this->tag.length = uint8_t((bytes+3)/4);
			memcpy(message, str, bytes);
		}
		uint16_t bytes;
		char message[InvocationBase::maxBytes-2];
	};

	struct Create : public UntypedMemory::CreateBase {
		Create(CapPtr dst, CapPtr factory) : CreateBase(dst, factory) {}
	};

	template<class IMPL, class... ARGS>
	static Error dispatchRequest(IMPL* obj, uint8_t m, ARGS const&...args) {
		switch(Methods(m)) {
		case PRINT_MESSAGE: return obj->printMessage(args...);
		default: return Error::NOT_IMPLEMENTED;
		}
	}

};

} // namespace protocol
} // namespace mythos
\end{lstlisting}


Additionally, the format of the invocation buffer has to be specified here,
inside a method-specific struct which includes a constructor that receives all
arguments, that were previously passed to the runtime object.  Furthermore, the
method \texttt{dispatchMethod} has to be adapted to call the correct method of
the kernel object when receiving a message. This method of the kernel object
then carries out the actual work that the developer wanted to move into the
kernel.

The actual kernel object's implementation is stored in
\texttt{objects/<objectName>/\\objects}. Here, the method called by the
protocol's dispatcher has to be implemented. This method is responsible for
extracting the required information from the invocation buffer and processing
it. Data can be returned to the application through the invocation buffer.

% ------------------------------------------------------------------------------
% \bibliographystyle{alpha}
% \bibliography{literature}

\end{document}
