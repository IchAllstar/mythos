\input{header}

\title{MyThOS D4.3 Developer Cookbook}
\author{Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta}

\hypersetup{
  pdftitle={MyThOS D4.3 Developer Cookbook},
  pdfsubject={MyThOS Deliverable},
  pdfauthor={Stefan Bonfert, Vladimir Nikolov, Robert Kuban, Randolf Rotta},
  pdfkeywords={MyThOS} % comma separated
}

\begin{document}
\selectlanguage{ngerman}
\maketitle

\begin{abstract}
Dieses Deliverable richtet sich an externe Anwender und dokumentiert die Tools als auch die Grundzüge des Programmiermodells anhand von Beispielen („Kochrezepten“).
\end{abstract}

\newpage
\tableofcontents
% --- content ------------------------------------------------------------------

\selectlanguage{UKenglish}
\section{Compiling an Application}

The \mythos kernel loads an initial application after the operating system is booted and the available hardware is appropriately configured. This initial application is embedded into the kernel image and thus has to be compiled together with the kernel image. A dynamic application loader is intended to be included in future versions of \mythos.

Due to  the reduced nature of \mythos, applications have to be compiled carefully to be executable on \mythos. This will also be true once the dynamic application loader is in place. Currently \mythos does offer the full interface of commonly used libraries like LibC. Therefore, the compiler has to be instructed not to include exception handling into the code (\texttt{-fno-exceptions}) and omit including stack protectors (\texttt{-fno-stack-protector}). The linker has to be configured to not link against the standard libraries (\texttt{-nostdlib}) and link against all other libraries statically (\texttt{-static}), since dynamically loaded libraries are not yet supported by \mythos. However, GCC-specific functions are included in the code of \mythos. Therefore, these libraries have to be included into the code (\texttt{-lgcc}).

Since \mythos is designed to run on manycore architectures, which often have limited support for advanced istruction set extensions, these should be disabled in the compiler. When compiling an application for the Intel\textcopyright~Xeon~Phi\superscript{\texttrademark}, all of MMX, SSE, SSE2, SSE3 and 3DNow should be disabled (\textt{-mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow}).


\section{Interface of \mythos System Calls}
Compared to general purpose operating systems, \mythos offers a relatively
small set of system calls for the interaction of applications with the
operating system kernel. In the following all system calls are listed,
including a description of their semantics.

\begin{description}
\item[void syscall\_debug(char const* start, uint64\_t length):] This system
call is used to output debug messages to the text console. In the current
implementation, the output is redirected to a static memory buffer, from where
it is then output to the user's terminal by an helper application running on the
\mythos host. The parameter \texttt{start} points to the buffer contaitning the
text to be output, \texttt{length} determines the length of the string. After
the output is written into the buffer, the syscall returns to the application.
The actual output to the user's terminal is then executed asynchronously on the
host computer.
\item[void syscall\_exit(uint64\_t rescode):] This system call is called to exit
the currently running application. When issuing this system call, the currently
running \texttt{ExecutionContext} exits itself and yields control to the kernel.
The parameter \texttt{rescode} follows the usual semantics of a result code,
where the value $0$ indicates succesful execution of the application or thread,
while all other result codes indicate unsuccesful execution, with a semantic,
that is up to the application.
\item[KEvent syscall\_invoke(CapPtr portal, CapPtr object, void* userctx):] All
functionality in the kernel of \mythos is encapsulated into kernel objects.
Using this system call, applications can interact with these kernel objects in a
well-defined and controlled manner. This system call can be used to request a
specific service, from the kernel object \texttt{object}. For the communication
a portal is used, that is passed to the system call in the parameter
\texttt{portal}. The called kernel object does not necessarily have to be
located locally. The translation of the application's system calls to either
local or remote system calls is transparent to the user. An additional reference
\texttt{userctx} is passed, which is later returned to the application upon
reply of the kernel object. This system call is executed asynchronously.
Additional system calls have to be issued to check for the result of the
invocation.
\item[KEvent syscall\_poll():] This system call checks, whether the application
received a response to a previously issued system call or an invocation by a
remote portal. If a notification was received, this is indicated in
\texttt{state}-member of the returned \texttt{KEvent}-object. The reference,
that was passed to the corresponsding invoke system call (either locally or
remotely via a portal) is made available to the application in the
\texttt{user}-member of the returned object. This system call returnes
immediately, even if there was no notification pending.
\item[KEvent syscall\_wait():] This system call follows the same semantics as
the \texttt{syscall\_poll} system call, but blocks until a notification was
received. It's therefore follows a synchronous processing model.
\item[KEvent syscall\_invoke\_poll(CapPtr portal, CapPtr object, void* userctx)]
\item[KEvent syscall\_invoke\_wait(CapPtr portal, CapPtr object, void*
userctx):] These two system calls combine an invocation of a kernel object with
the check for pending notifications. They follow the semantics of the individual
system calls as described above and are available in a blocking (wait) and a
non-blocking (poll) implementation. The combination of two system calls into a
single one resembles the common send-recevice pattern and potentially can reduce
the number of required system calls and therefore the number of switches from
user space to kernel space and back.
\end{description}

\section{Interface of the \mythos Runtime Environment}
* Schnittstelle der User-Space Laufzeitumgebung

\section{Example Application}
* Beispiel und Hinweise für eine minimale Supervisor-Anwendung
* Beispiel-Anwendung

% ------------------------------------------------------------------------------
% \bibliographystyle{alpha}
% \bibliography{literature}

\end{document}
